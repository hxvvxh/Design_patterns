**************设计模式之单例模式 ****************

知识点
1：什么是原子操作？
简单来说，原子操作（atomic）就是不可分割的操作，在计算机中，就是指不会因为线程调度被打断的操作。
比如，简单的赋值是一个原子操作：
        m = 6; // 这是个原子操作
假如m原先的值为0，那么对于这个操作，要么执行成功m变成了6，要么是没执行m还是0，
而不会出现诸如m=3这种中间态――即使是在并发的线程中。
而，声明并赋值就不是一个原子操作：
       int n = 6; // 这不是一个原子操作对于这个语句，
至少有两个操作：①声明一个变量n②给n赋值为6――这样就会有一个中间状态：变量n已经被声明了但是还没有被赋值的状态。
     ――这样，在多线程中，由于线程执行顺序的不确定性，如果两个线程都使用m，就可能会导致不稳定的结果出现。

2:什么是指令重排？

简单来说，就是计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整.
int a ;   // 语句1 
a = 8 ;   // 语句2
int b = 9 ;     // 语句3
int c = a + b ; // 语句4

正常来说，对于顺序结构，执行的顺序是自上到下，也即1234。
但是，由于指令重排的原因，因为不影响最终的结果，所以，实际执行的顺序可能会变成3124或者1324。
由于语句3和4没有原子性的问题，语句3和语句4也可能会拆分成原子操作，再重排。
――也就是说，对于非原子性的操作，在不影响最终结果的情况下，其拆分成的原子操作可能会被重新排列执行顺序。

3：volatile
用于将变量标记为“存储于主内存中”。
更确切地说，对 volatile 变量的每次读操作都会直接从计算机的主存中读取，而不是从 cpu 缓存中读取；
同样，每次对…… volatile 变量的写操作都会直接写入到主存中，而不仅仅写入到 cpu 缓存里



4：饿汉式单例 懒汉式单例
   饿汉式单例：管你需不需要，在一开始就已经创建了这个类
   懒汉式单例：只在需要的时候才会创建
   
5：枚举单例 （****目前实现单例模式最好的方式 没有之一****）
   **********重点了解***************
 